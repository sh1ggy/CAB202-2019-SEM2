<!DOCTYPE html>
<!-- saved from url=(0125)https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>CAB202 Topic 9 – Timers and Interrupts</title>

	<style type="text/css">
		
			body {
				max-width: 50em;
				/* font-family: sans-serif; */
				margin: auto;
				line-height: 1.4em;
				background-color: #F1F1F1;
			}
		

		.indent {
			margin-left: 0.6cm;
		}

		.codeblock {
			font-size: +1;
			font-family: monospace;
			font-weight: bold;
			background-color: #303030;
			color: #dcdcdc;
			/* font-size: large; */
		}

		.codeDiv {
			overflow: scroll;
			border: 1px solid gray;
		}

		pre {
			border: 1px solid gray;
			padding: 6pt;
			width: 100%;
		}

		textarea {
			margin-top: 6pt;
		}

		td {
			/* width: 4in; */
			vertical-align: top;
		}

		code {
			font-size: medium;
			font-weight: bold;
		}

		li {
			margin-bottom: 6pt;
		}

		li ul {
			margin-top: 6pt;
		}

		.section {
			margin-left: 0.6cm;
		}

		.subsection {
			margin-left: 0.6cm;
		}

		span.li  {display: list-item; margin-left: 0.6cm}

		span.li2  {display: list-item; margin-left: 1.2cm}

		td.truth_table { text-align: center; width: 1cm; vertical-align: middle; }

		div.truth_table_container { display: inline-block; width: 5.5cm; vertical-align: top; text-align: center; }
		td.truth_value { background-color: #dddddd; }

		.sc0 {
	}
	.sc2 {
		color: #1E9AE0;
	}
	.sc4 {
		color: #FF3A83;
	}
	.sc5 {
		color: #F6F080;
	}
	.sc6 {
		color: #55E439;
	}
	.sc9 {
		color: cyan;
	}
	.sc10 {
		color: #FFAA00;
	}
	.sc11 {
		color: #F8F8F8;
	}
	.sc16 {
		color: #FFAA00;
	}
	</style>
<style type="text/css">
:root #content > #right > .dose > .dosesingle,
:root #content > #center > .dose > .dosesingle
{ display: none !important; }</style></head><body><h1 class="document_title">CAB202 Topic 9 – Timers and Interrupts</h1>
<p>Authors:</p>
	<ul><li>Lawrence Buckingham QUT (Present version)</li>
<li>Luis Mejias QUT (2016, 2017/01, 2018/02, 2019/02)</li>
<li>Ben Upcroft QUT (2015).</li>
</ul>
	
    <h2><a name="_contents">Contents</a></h2>
    
	<ul>
			<li> 
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#roadmap" title="roadmap">Roadmap</a>
	
			
	
	
	
	
	</li>
		
			<li> 
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#format" title="format">References</a>
	
			
	
	
	
	
	</li>
		
			<li> 
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#de_bouncing" title="de_bouncing">De-bouncing (a problem that can be solved with interrupts)</a>
	
			
	
	
	    <ul>
			    <li>
    
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#debounce_problem" title="debounce_problem">The problem</a>
    
    
					</li>
	        
			    <li>
    
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#debounce_soln_1" title="debounce_soln_1">Delay-based de-bouncing (which is not very good)</a>
    
    
					<ul>
			    <li><a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#dbs1_idea" title="dbs1_idea">Idea</a>
    </li>
	        
			    <li><a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#dbs1_impl" title="dbs1_impl">Implementation</a>
    </li>
	        
			    <li><a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#dbs1_disc" title="dbs1_disc">Pros and Cons</a>
    </li>
	        </ul>
	
	</li>
	        
			    <li>
    
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#debounce_soln_2" title="debounce_soln_2">Non-blocking de-bouncing (which is much better but not quite ideal)</a>Æ’
    
    
					<ul>
			    <li><a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#dbs1_idea" title="dbs1_idea">Idea</a>
    </li>
	        
			    <li><a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#dbs1_impl" title="dbs1_impl">Implementation</a>
    </li>
	        
			    <li><a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#dbs1_disc" title="dbs1_disc">Pros and Cons</a>
    </li>
	        </ul>
	
	</li>
	        
			    <li>
    
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#debounce_conclusion" title="debounce_conclusion">De-bouncing conclusion</a>
    
    
					</li>
	        </ul>
	
	
	
	</li>
		
			<li> 
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#timers" title="timers">ATMega32U4 Timers</a>
	
			
	
	
	    <ul>
			    <li>
    
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#timer_intro" title="timer_intro">Timer Introduction</a>
    
    
					</li>
	        
			    <li>
    
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#timer0_registers" title="timer0_registers">Timer0 registers (Datasheet, Section 13.8)</a>
    
    
					</li>
	        
			    <li>
    
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#timer0" title="timer0">Case study: Set Up and Read Time From Timer0</a>
    
    
					</li>
	        </ul>
	
	
	
	</li>
		
			<li> 
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#interrupt" title="interrupt">The Timer Overflow Interrupt</a>
	
			
	
	
	    <ul>
			    <li>
    
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#interrupt_caveat" title="interrupt_caveat">Caveat</a>
    
    
					</li>
	        
			    <li>
    
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#whats_an_interrupt" title="whats_an_interrupt">What’s an interrupt?</a>
    
    
					</li>
	        
			    <li>
    
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#timer_overflow_demo" title="timer_overflow_demo">Implementing Timer Overflow ISR</a>
    
    
					</li>
	        </ul>
	
	
	
	</li>
		
			<li> 
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#appendices" title="appendices">Appendices</a>
	
			
	
	
	    <ul>
			    <li>
    
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#packed_boolean_array" title="packed_boolean_array">Appendix 1: Bit-packed boolean arrays</a>
    
    
					</li>
	        
			    <li>
    
	<a href="https://blackboard.qut.edu.au/bbcswebdav/pid-8117932-dt-content-rid-26794327_1/courses/CAB202_19se2/CAB202-Topic09-Notes.html#cheat_sheet" title="cheat_sheet">Appendix 2: Digital I/O Cheat Sheet</a>
    
    
					</li>
	        </ul>
	
	
	
	</li>
		
    	</ul>

	<hr>
	
	

    
		<h2><a name="roadmap">Roadmap</a></h2>
		<div class="section">
		<p><em>Previously, on CAB202:</em></p>
		<ol start="7"><li>Teensy – Introduction to Microcontrollers; Digital Input/Output; Bitwise operations.</li>
<li>LCD Display – sending digital signals to a device; directly controlling the LCD display.</li>
</ol>
		<p><em>This week:</em></p>
		<ol start="9"><li><b>Timers and Interrupts – asynchronous programming.</b></li>
</ol>
		<p><em>Still to come:</em></p>
		<ol start="10"><li>Serial Communication – communicating with another computer.</li>
<li>Analogue to Digital Conversion; Pulse Width Modulation.</li>
<li>TBA.</li>
</ol>
</div>
		<hr>
	
	

    
		<h2><a name="format">References</a></h2>
		<div class="section">
		<p>Recommended reading:</p>

		<ul><li>Blackboard&#8594;Learning Resources&#8594;Microcontrollers&#8594;atmega32u4 datasheet.pdf.</li>
</ul>
	</div>
		<hr>
	
	

    
		<h2><a name="de_bouncing">De-bouncing (a problem that can be solved with interrupts)</a></h2>
		<div class="section">
		
	
    
		<h3><a name="debounce_problem">The problem</a></h3>
		<div class="subsection">
			<p>Switches are prone to a phenomenon known as <em>bouncing</em>, in which spurious “click” events are detected.</p>

			<ul><li>Consider a pull-up resistor:
				<p style="margin-left=0.5in;">
    
    <img src="./[WK 9] Timers and Interrupts_files/Switch.png" width="153" height="201" alt="Representation of switch"></p>
				</li>
<li>When the switch opens and closes, current flows in an interrupted pattern while the connection is made, then settles to either on or off.
				<p style="margin-left=0.5in;">
    
    <img src="./[WK 9] Timers and Interrupts_files/Current.png" width="320" height="239" alt="Representation of switch"></p>
				</li>
<li>Bouncing matters when we want precise recognition of “click” events.
				<ul><li>A button click is recognised when a switch is <em>pressed</em> and then <em>released</em> as part of a single gesture.</li>
<li>This corresponds to a switch transitioning from <em>open</em> to <em>closed</em> and then back to <em>open</em>.</li>
</ul></li>
</ul>
			<p>The <code>BounceDemo</code> program illustrates bouncing.
				</p>
<p style="margin-left: 0.5in;"></p><pre style="line-height: 1.2; background: #2A211C; color: #BDAE9D; overflow-x: scroll; font-family: monospace; max-width: 100%;"><span class="sc2">/*
**	BounceDemo.c
**
**	Demonstrates bouncing effect in tactile switch.
**
**	Lawrence Buckingham, QUT, September 2017.
**	(C) Queensland University of Technology.
*/</span>
<span class="sc10">#include &lt;stdint.h&gt;
</span><span class="sc10">#include &lt;stdio.h&gt;
</span><span class="sc10">#include &lt;avr/io.h&gt; 
</span><span class="sc10">#include &lt;avr/interrupt.h&gt;
</span><span class="sc10">#include &lt;util/delay.h&gt;
</span><span class="sc10">#include &lt;cpu_speed.h&gt;
</span>
<span class="sc10">#include &lt;graphics.h&gt;
</span><span class="sc10">#include &lt;macros.h&gt;
</span><span class="sc10">#include "lcd_model.h"
</span>
<span class="sc10">void</span> <span class="sc11">draw_all</span>(<span class="sc10">void</span>);
<span class="sc10">void</span> <span class="sc11">draw_int</span>( <span class="sc9">uint8_t</span> <span class="sc11">x</span>, <span class="sc9">uint8_t</span> <span class="sc11">y</span>, <span class="sc9">int</span> <span class="sc11">value</span>, <span class="sc9">colour_t</span> <span class="sc11">colour</span> );

<span class="sc10">void</span> <span class="sc11">setup</span>(<span class="sc10">void</span>) {
	<span class="sc11">set_clock_speed</span>(<span class="sc10">CPU_8MHz</span>);
	<span class="sc11">lcd_init</span>(<span class="sc10">LCD_DEFAULT_CONTRAST</span>);
	<span class="sc11">draw_all</span>();
	<span class="sc11">CLEAR_BIT</span>(<span class="sc11">DDRD</span>, <span class="sc4">1</span>); <span class="sc2">// up</span>
	<span class="sc11">CLEAR_BIT</span>(<span class="sc11">DDRF</span>, <span class="sc4">6</span>); <span class="sc2">// left_button</span>
}

<span class="sc9">uint16_t</span> <span class="sc11">counter</span> = <span class="sc4">0</span>;
<span class="sc9">char</span> <span class="sc11">buffer</span>[<span class="sc4">10</span>];

<span class="sc10">void</span> <span class="sc11">process</span>(<span class="sc10">void</span>) {
	<span class="sc2">// Detect a Click on left button</span>
	<span class="sc5">if</span> ( <span class="sc11">BIT_IS_SET</span>(<span class="sc11">PINF</span>, <span class="sc4">6</span>) ) {
		<span class="sc5">while</span> ( <span class="sc11">BIT_IS_SET</span>(<span class="sc11">PINF</span>, <span class="sc4">6</span>) ) {
			<span class="sc2">// Block until button released.</span>
		}
		<span class="sc2">// Button has now been pressed and released...</span>
		<span class="sc11">counter</span> ++;
	}

	<span class="sc2">// Display and wait if joystick up.</span>
	<span class="sc5">if</span> ( <span class="sc11">BIT_IS_SET</span>(<span class="sc11">PIND</span>, <span class="sc4">1</span>) ) {
		<span class="sc11">draw_all</span>();

		<span class="sc5">while</span> ( <span class="sc11">BIT_IS_SET</span>(<span class="sc11">PIND</span>, <span class="sc4">1</span>) ) {
			<span class="sc2">// Block until joystick released.</span>
		}
	}
}

<span class="sc9">int</span> <span class="sc11">main</span>(<span class="sc10">void</span>) {
	<span class="sc11">setup</span>();

	<span class="sc5">for</span> ( ;; ) {
		<span class="sc11">process</span>();
	}
}
<span class="sc2">// -------------------------------------------------</span>
<span class="sc2">// Helper functions.</span>
<span class="sc2">// -------------------------------------------------</span>
<span class="sc10">void</span> <span class="sc11">draw_all</span>( <span class="sc10">void</span> ) {
	<span class="sc11">clear_screen</span>();
	<span class="sc11">draw_string</span>( <span class="sc4">0</span>, <span class="sc4">0</span>, <span class="sc6">"BounceDemo"</span>, <span class="sc11">FG_COLOUR</span> );
	<span class="sc11">draw_string</span>( <span class="sc4">0</span>, <span class="sc4">10</span>, <span class="sc6">"Clk lft to count</span>, <span class="sc11">FG_COLOUR</span> );
	<span class="sc11">draw_string</span>( <span class="sc4">0</span>, <span class="sc4">20</span>, <span class="sc6">"Joystk up to view"</span>, <span class="sc11">FG_COLOUR</span> );
	<span class="sc11">draw_int</span>(<span class="sc4">10</span>, <span class="sc4">30</span>, <span class="sc11">counter</span>, <span class="sc11">FG_COLOUR</span>);
	<span class="sc11">show_screen</span>();
}

<span class="sc10">void</span> <span class="sc11">draw_int</span>(<span class="sc9">uint8_t</span> <span class="sc11">x</span>, <span class="sc9">uint8_t</span> <span class="sc11">y</span>, <span class="sc9">int</span> <span class="sc11">value</span>, <span class="sc9">colour_t</span> <span class="sc11">colour</span>) {
	<span class="sc11">snprintf</span>(<span class="sc11">buffer</span>, <span class="sc5">sizeof</span>(<span class="sc11">buffer</span>), <span class="sc6">"%d"</span>, <span class="sc11">value</span> );
	<span class="sc11">draw_string</span>(<span class="sc11">x</span>, <span class="sc11">y</span>, <span class="sc11">buffer</span>, <span class="sc11">colour</span>);
}
</pre>
		<p></p>
<p>This program uses a polling approach to detect click events on the left button (SW0 in the pin-out diagram).</p>

			<ul><li>Click-detection is done in the <code>process</code> function. The logic is very simple:
				<ul><li>If the left switch is closed, wait for it to become open, and then register a <em>click</em>.</li>
<li>Waiting with a loop in this way is called <em>busy waiting</em> – the CPU repeatedly executes the test in the while loop until the condition becomes false, at which point the program can move on.</li>
<li>Busy-waiting is avoided wherever possible because it locks the CPU up doing nothing, and because it may result in unpredictable delays.</li>
</ul></li>
<li>Bouncing happens on a very short timescale relative to the physical act of pressing and releasing the switch, so it is quite a challenge to demonstrate on purpose.
				<ul><li>If we introduce any significant delay, the effect is obscured.</li>
<li>To make the effect visible, this program performs absolutely minimal processing.</li>
<li>When a left button-click is detected, a counter increments silently.</li>
<li>To view the current value of the counter, push the joystick up.</li>
<li>Try multiple clicks on the left button and then display them by pressing joystick up. Do the clicks and display values match?</li>
		</ul>
</li>
</ul>
		</div> 
		
	
    
		<h3><a name="debounce_soln_1">Delay-based de-bouncing (which is not very good)</a></h3>
		<div class="subsection">
			
	
    
		<h3><a name="dbs1_idea">Idea</a></h3>
		<div class="subsection">
				<p>About the simplest work-around is to try to take advantage of the short duration of the transient behaviour.</p>

				<ul><li>This click-detection algorithm is almost identical to the polling algorithm above.</li>
<li>We introduce a short delay just after the button-press is detected, but before the busy-wait that detects the button-release.</li>
<li>The hope is that the contact has closed properly by the time we enter the wait loop.</li>
</ul>
			</div>
			
	
    
		<h3><a name="dbs1_impl">Implementation</a></h3>
		<div class="subsection">
				<p>Simple delay-based de-bouncing is demonstrated in <code>DelayDebounceDemo.c</code>:
					</p>
<p style="margin-left: 0.5in;"></p><pre style="line-height: 1.2; background: #2A211C; color: #BDAE9D; overflow-x: scroll; font-family: monospace; max-width: 100%;"><span class="sc2">/*
**	DelayDebounceDemo.c
**
**	Demonstrates simple delay-based de-bounce in tactile switch.
**
**	Lawrence Buckingham, QUT, September 2017.
**	(C) Queensland University of Technology.
*/</span>
<span class="sc10">#include &lt;stdint.h&gt;
</span><span class="sc10">#include &lt;stdio.h&gt;
</span><span class="sc10">#include &lt;avr/io.h&gt; 
</span><span class="sc10">#include &lt;avr/interrupt.h&gt;
</span><span class="sc10">#include &lt;util/delay.h&gt;
</span><span class="sc10">#include &lt;cpu_speed.h&gt;
</span>
<span class="sc10">#include &lt;graphics.h&gt;
</span><span class="sc10">#include &lt;macros.h&gt;
</span><span class="sc10">#include "lcd_model.h"
</span>
<span class="sc10">#define DEBOUNCE_MS (150)
</span>
<span class="sc10">void</span> <span class="sc11">draw_all</span>(<span class="sc10">void</span>);
<span class="sc10">void</span> <span class="sc11">draw_int</span>( <span class="sc9">uint8_t</span> <span class="sc11">x</span>, <span class="sc9">uint8_t</span> <span class="sc11">y</span>, <span class="sc9">int</span> <span class="sc11">value</span>, <span class="sc9">colour_t</span> <span class="sc11">colour</span> );

<span class="sc10">void</span> <span class="sc11">setup</span>(<span class="sc10">void</span>) {
	<span class="sc11">set_clock_speed</span>(<span class="sc10">CPU_8MHz</span>);
	<span class="sc11">lcd_init</span>(<span class="sc10">LCD_DEFAULT_CONTRAST</span>);
	<span class="sc11">draw_all</span>();
	<span class="sc11">CLEAR_BIT</span>(<span class="sc11">DDRD</span>, <span class="sc4">1</span>); <span class="sc2">// up</span>
	<span class="sc11">CLEAR_BIT</span>(<span class="sc11">DDRF</span>, <span class="sc4">6</span>); <span class="sc2">// left_button</span>
}

<span class="sc9">uint16_t</span> <span class="sc11">counter</span> = <span class="sc4">0</span>;
<span class="sc9">char</span> <span class="sc11">buffer</span>[<span class="sc4">10</span>];

<span class="sc10">void</span> <span class="sc11">process</span>(<span class="sc10">void</span>) {
	<span class="sc2">// Detect a Click on left button</span>
	<span class="sc5">if</span> ( <span class="sc11">BIT_IS_SET</span>(<span class="sc11">PINF</span>, <span class="sc4">6</span>) ) {
		_<span class="sc11">delay_ms</span>(<span class="sc10">DEBOUNCE_MS</span>);

		<span class="sc5">while</span> ( <span class="sc11">BIT_IS_SET</span>(<span class="sc11">PINF</span>, <span class="sc4">6</span>) ) {
			<span class="sc2">// Block until button released.</span>
		}
		<span class="sc2">// Button has now been pressed and released...</span>
		<span class="sc11">counter</span> ++;
	}

	<span class="sc2">// Display and wait if joystick up.</span>
	<span class="sc5">if</span> ( <span class="sc11">BIT_IS_SET</span>(<span class="sc11">PIND</span>, <span class="sc4">1</span>) ) {
		<span class="sc11">draw_all</span>();

		<span class="sc5">while</span> ( <span class="sc11">BIT_IS_SET</span>(<span class="sc11">PIND</span>, <span class="sc4">1</span>) ) {
			<span class="sc2">// Block until joystick released.</span>
		}
	}
}

<span class="sc9">int</span> <span class="sc11">main</span>(<span class="sc10">void</span>) {
	<span class="sc11">setup</span>();

	<span class="sc5">for</span> ( ;; ) {
		<span class="sc11">process</span>();
	}
}
<span class="sc2">// -------------------------------------------------</span>
<span class="sc2">// Helper functions.</span>
<span class="sc2">// -------------------------------------------------</span>
<span class="sc10">void</span> <span class="sc11">draw_all</span>( <span class="sc10">void</span> ) {
	<span class="sc11">clear_screen</span>();
	<span class="sc11">draw_string</span>( <span class="sc4">0</span>, <span class="sc4">0</span>, <span class="sc6">"DelayDebounceDemo"</span>, <span class="sc11">FG_COLOUR</span> );
	<span class="sc11">draw_string</span>( <span class="sc4">0</span>, <span class="sc4">10</span>, <span class="sc6">"Clk lft to count</span>, <span class="sc11">FG_COLOUR</span> );
	<span class="sc11">draw_string</span>( <span class="sc4">0</span>, <span class="sc4">20</span>, <span class="sc6">"Joystk up to view"</span>, <span class="sc11">FG_COLOUR</span> );
	<span class="sc11">draw_int</span>(<span class="sc4">10</span>, <span class="sc4">30</span>, <span class="sc11">counter</span>, <span class="sc11">FG_COLOUR</span>);
	<span class="sc11">show_screen</span>();
}

<span class="sc10">void</span> <span class="sc11">draw_int</span>(<span class="sc9">uint8_t</span> <span class="sc11">x</span>, <span class="sc9">uint8_t</span> <span class="sc11">y</span>, <span class="sc9">int</span> <span class="sc11">value</span>, <span class="sc9">colour_t</span> <span class="sc11">colour</span>) {
	<span class="sc11">snprintf</span>(<span class="sc11">buffer</span>, <span class="sc5">sizeof</span>(<span class="sc11">buffer</span>), <span class="sc6">"%d"</span>, <span class="sc11">value</span> );
	<span class="sc11">draw_string</span>(<span class="sc11">x</span>, <span class="sc11">y</span>, <span class="sc11">buffer</span>, <span class="sc11">colour</span>);
}
</pre>
		<p></p>

			</div>
			
	
    
		<h3><a name="dbs1_disc">Pros and Cons</a></h3>
		<div class="subsection">
				<p>Introducing a delay between detection of button-press and button-release “kind of” works.
					But it has some problems.</p>

				<ul><li>If the delay is too short, it just doesn’t work.</li>
<li>If the delay is too long, then the user may click faster than we can detect.</li>
<li>It is still unreliable because it still depends heavily on how fast the user do button-presses.</li>
<li>Regardless of the delay duration, synchronous click detection in this way is a bad idea.
					<ul><li>When we block the main event loop, everything stops until the click is detected.</li>
</ul></li>
</ul>
		  </div>
		</div> 

		
	
    
		<h3><a name="debounce_soln_2">Non-blocking de-bouncing (which is much better but not quite ideal)</a></h3>
		<div class="subsection">
			
	
    
		<h3><a name="dbs1_idea">Idea</a></h3>
		<div class="subsection">
				<p>Both algorithms above rely on a two-phase procedure to detect a click:
					</p><ol><li>Detect that the button is pressed.</li>
<li>Wait for the button to be released.</li>
</ol><p></p>
<p>The busy wait is the main problem: the event loop stalls while we wait for the button to be released. In the present section we examine an elegant non-blocking solution.</p>

				<ul><li>This algorithm hinges on the idea that at any given time the switch may be undergoing rapid on/off transitions due to bouncing, but that eventually the switch will settle to a stable configuration, at which point the button is either <em>definitely pressed</em> or <em>definitely not pressed</em>.
					<ul><li>Initially, we have no opinion as to the configuration.</li>
<li>As time passes we accumulate a log of evidence which sways between the two options: <em>definitely pressed</em> or <em>definitely not pressed</em>.</li>
<li>If enough evidence accumulates one way or the other, we accept the option.</li>
<li>We then start again.</li>
</ul></li>
<li>To decide if the button is in a stable configuration, we repeatedly (at high frequency) sample the button state.
					<ul><li>Every time we see the switch is closed, our opinion moves toward the conclusion that the button <em>may be</em> definitely pressed.</li>
<li>If we see the switch closed many times without ever seeing it open, we conclude that the button <em>is</em> definitely pressed.</li>
<li>Every time we see the switch open, we conclude that the button cannot possibly be definitely pressed, and our opinion moves toward the opposite conclusion, namely that the button <em>may not be</em> definitely pressed.</li>
<li>If we see the switch open many times without ever seeing it closed, we conclude that the button <em>is not</em> definitely pressed.</li>
</ul></li>
</ul>
			</div>
			
	
    
		<h3><a name="dbs1_impl">Implementation</a></h3>
		<div class="subsection">
				<p>An implementation of this algorithm is provided in <code>NonblockingDebounceDemo.c</code>:
					</p>
<p style="margin-left: 0.5in;"></p><pre style="line-height: 1.2; background: #2A211C; color: #BDAE9D; overflow-x: scroll; font-family: monospace; max-width: 100%;"><span class="sc2">/*
**	NonblockingDebounceDemo.c
**
**	A non-blocking poll-based de-bounce in tactile switch.
**	(Adapted from unattributed source code used in CAB202
**	Semester 1, 2017)
**
**	Lawrence Buckingham, QUT, September 2017.
**	(C) Queensland University of Technology.
*/</span>
<span class="sc10">#include &lt;stdint.h&gt;
</span><span class="sc10">#include &lt;stdio.h&gt;
</span><span class="sc10">#include &lt;avr/io.h&gt; 
</span><span class="sc10">#include &lt;avr/interrupt.h&gt;
</span><span class="sc10">#include &lt;util/delay.h&gt;
</span><span class="sc10">#include &lt;cpu_speed.h&gt;
</span>
<span class="sc10">#include &lt;graphics.h&gt;
</span><span class="sc10">#include &lt;macros.h&gt;
</span><span class="sc10">#include "lcd_model.h"
</span>
<span class="sc5">typedef</span> <span class="sc5">enum</span> { <span class="sc11">false</span>, <span class="sc11">true</span> } <span class="sc9">bool</span>;

<span class="sc10">void</span> <span class="sc11">draw_all</span>(<span class="sc10">void</span>);
<span class="sc10">void</span> <span class="sc11">draw_int</span>(<span class="sc9">uint8_t</span> <span class="sc11">x</span>, <span class="sc9">uint8_t</span> <span class="sc11">y</span>, <span class="sc9">int</span> <span class="sc11">value</span>, <span class="sc9">colour_t</span> <span class="sc11">colour</span>);
<span class="sc9">bool</span> <span class="sc11">left_button_clicked</span>(<span class="sc10">void</span>);

<span class="sc10">void</span> <span class="sc11">setup</span>(<span class="sc10">void</span>) {
	<span class="sc11">set_clock_speed</span>(<span class="sc10">CPU_8MHz</span>);
	<span class="sc11">lcd_init</span>(<span class="sc10">LCD_DEFAULT_CONTRAST</span>);
	<span class="sc11">draw_all</span>();
	<span class="sc11">CLEAR_BIT</span>(<span class="sc11">DDRD</span>, <span class="sc4">1</span>); <span class="sc2">// up</span>
	<span class="sc11">CLEAR_BIT</span>(<span class="sc11">DDRF</span>, <span class="sc4">6</span>); <span class="sc2">// left_button</span>
}

<span class="sc2">// State machine for "button pressed"</span>
<span class="sc9">bool</span> <span class="sc11">pressed</span> = <span class="sc11">false</span>;
<span class="sc9">uint16_t</span> <span class="sc11">closed_num</span> = <span class="sc4">0</span>;
<span class="sc9">uint16_t</span> <span class="sc11">open_num</span> = <span class="sc4">0</span>;

<span class="sc10">#define THRESHOLD (1000)
</span>
<span class="sc9">bool</span> <span class="sc11">left_button_clicked</span>(<span class="sc10">void</span>) {
	<span class="sc2">// Detect a Click on left button</span>
	<span class="sc9">bool</span> <span class="sc11">was_pressed</span> = <span class="sc11">pressed</span>;

	<span class="sc5">if</span> ( <span class="sc11">BIT_IS_SET</span>(<span class="sc11">PINF</span>, <span class="sc4">6</span>) ) {
		<span class="sc11">closed_num</span>++;
		<span class="sc11">open_num</span> = <span class="sc4">0</span>;

		<span class="sc5">if</span> ( <span class="sc11">closed_num</span>  &gt; <span class="sc10">THRESHOLD</span> ) {
			<span class="sc5">if</span> ( !<span class="sc11">pressed</span> ) {
				<span class="sc11">closed_num</span> = <span class="sc4">0</span>;
			}

			<span class="sc11">pressed</span> = <span class="sc11">true</span>;
		}
	}
	<span class="sc5">else</span> {
		<span class="sc11">open_num</span>++;
		<span class="sc11">closed_num</span> = <span class="sc4">0</span>;

		<span class="sc5">if</span> ( <span class="sc11">open_num</span> &gt; <span class="sc10">THRESHOLD</span> ) {
			<span class="sc5">if</span> ( <span class="sc11">pressed</span> ) {
				<span class="sc11">open_num</span> = <span class="sc4">0</span>;
			}

			<span class="sc11">pressed</span> = <span class="sc11">false</span>;
		}
	}

	<span class="sc5">return</span> <span class="sc11">was_pressed</span> &amp;&amp; !<span class="sc11">pressed</span>;
}

<span class="sc2">// Auxiliary variables</span>
<span class="sc9">uint16_t</span> <span class="sc11">counter</span> = <span class="sc4">0</span>;
<span class="sc9">char</span> <span class="sc11">buffer</span>[<span class="sc4">10</span>];

<span class="sc10">void</span> <span class="sc11">process</span>(<span class="sc10">void</span>) {
	<span class="sc5">if</span> ( <span class="sc11">left_button_clicked</span>() ) {
		<span class="sc11">counter</span>++;
	}

	<span class="sc2">// Display and wait if joystick up.</span>
	<span class="sc5">if</span> ( <span class="sc11">BIT_IS_SET</span>(<span class="sc11">PIND</span>, <span class="sc4">1</span>) ) {
		<span class="sc11">draw_all</span>();

		<span class="sc5">while</span> ( <span class="sc11">BIT_IS_SET</span>(<span class="sc11">PIND</span>, <span class="sc4">1</span>) ) {
			<span class="sc2">// Block until joystick released.</span>
		}
	}
}

<span class="sc9">int</span> <span class="sc11">main</span>(<span class="sc10">void</span>) {
	<span class="sc11">setup</span>();

	<span class="sc5">for</span> ( ;; ) {
		<span class="sc11">process</span>();
	}
}
<span class="sc2">// -------------------------------------------------</span>
<span class="sc2">// Helper functions.</span>
<span class="sc2">// -------------------------------------------------</span>
<span class="sc10">void</span> <span class="sc11">draw_all</span>(<span class="sc10">void</span>) {
	<span class="sc11">clear_screen</span>();
	<span class="sc11">draw_string</span>(<span class="sc4">0</span>, <span class="sc4">0</span>, <span class="sc6">"DelayDebounceDemo"</span>, <span class="sc11">FG_COLOUR</span>);
	<span class="sc11">draw_string</span>(<span class="sc4">0</span>, <span class="sc4">10</span>, <span class="sc6">"Clk lft to count</span>, <span class="sc11">FG_COLOUR</span>);
	<span class="sc11">draw_string</span>(<span class="sc4">0</span>, <span class="sc4">20</span>, <span class="sc6">"Joystk up to view"</span>, <span class="sc11">FG_COLOUR</span>);
	<span class="sc11">draw_int</span>(<span class="sc4">10</span>, <span class="sc4">30</span>, <span class="sc11">counter</span>, <span class="sc11">FG_COLOUR</span>);
	<span class="sc11">show_screen</span>();
}

<span class="sc10">void</span> <span class="sc11">draw_int</span>(<span class="sc9">uint8_t</span> <span class="sc11">x</span>, <span class="sc9">uint8_t</span> <span class="sc11">y</span>, <span class="sc9">int</span> <span class="sc11">value</span>, <span class="sc9">colour_t</span> <span class="sc11">colour</span>) {
	<span class="sc11">snprintf</span>(<span class="sc11">buffer</span>, <span class="sc5">sizeof</span>(<span class="sc11">buffer</span>), <span class="sc6">"%d"</span>, <span class="sc11">value</span>);
	<span class="sc11">draw_string</span>(<span class="sc11">x</span>, <span class="sc11">y</span>, <span class="sc11">buffer</span>, <span class="sc11">colour</span>);
}
</pre>
		<p></p>
<p>The algorithm is implemented in the <code>left_button_clicked</code> function.</p>

				<ul><li>We use a boolean variable called <code>pressed</code> to record whether the button is <em>definitely pressed</em> or <em>definitely not pressed</em>.</li>
<li>Along with <code>pressed</code>, we keep a pair of counters.
					<ul><li><code>open_num</code> is the number of consecutive times the switch has been observed to be open.</li>
<li><code>closed_num</code> is the number of consecutive times the switch has been observed to be closed.</li>
</ul></li>
<li>Every time we poll the switch state, we update one or more of these three variables.
					<ul><li>If the switch is closed, we increment <code>closed_num</code> and restore <code>open_num</code> to 0. If <code>open_num</code> passes a threshold (in this case, <code>1000</code>), we assign <code>pressed&nbsp;=&nbsp;true</code> –; <em>definitely pressed</em>.</li>
<li>If the switch is open, we increment <code>open_num</code> and restore <code>closed_num</code> to 0. If <code>closed_num</code> passes the threshold, we assign <code>pressed&nbsp;=&nbsp;false</code> –; not <em>definitely pressed</em>.</li>
</ul></li>
<li>Each time we settle on a switch state, we reset the counters and the accumulation process starts again.</li>
</ul>
			</div>
			
	
    
		<h3><a name="dbs1_disc">Pros and Cons</a></h3>
		<div class="subsection">
				<p>This non-blocking de-bounce method is pretty good.</p>

				<ul><li>The boolean <code>pressed</code> variable is a reliable indication of the true state of the button.</li>
<li>Click tests based on transitions between <code>pressed&nbsp;==&nbsp;true</code> and <code>pressed&nbsp;==&nbsp;false</code> are very reliable.</li>
</ul>
				<p>Perceived problems:</p>

				<ul><li>The decision depends on <code>THRESHOLD</code>, which must be just right.
					<ul><li>The correct value will depend not only on the microcontroller clock speed, but also on the time between calls to <code>left_button_clicked</code>.</li>
<li>Performance may not be consistent due to factors elsewhere in the program.</li>
<li><em>The algorithm polls the switch in the main event loop, which means we can never guarantee reliable performance.</em></li>
</ul></li>
</ul>
			</div>
		</div> 
		
		
	
    
		<h3><a name="debounce_conclusion">De-bouncing conclusion</a></h3>
		<div class="subsection">
			<ul><li>We have demonstrated switch bounce, and examined a two ways to address the problem.</li>
<li>A non-blocking algorithm has been developed which is very good, but still relies on polling.</li>
<li>To perfect the algorithm, we need a way to sample the physical state of the switch at a fairly high and constant frequency. <strong>Hint: Timers and Interrupts</strong>.</li>
<li><em>This forms one of the Topic 9 Portfolio exercises.</em></li>
</ul>
		</div>
	</div>
		<hr>
	
	

    
		<h2><a name="timers">ATMega32U4 Timers</a></h2>
		<div class="section">
		
	
    
		<h3><a name="timer_intro">Timer Introduction</a></h3>
		<div class="subsection">
			<p>A timer is a semi-autonomous subsystem which runs alongside the CPU.</p>
			<ul><li><em>Refer: ATMega32U4 Datasheet, Chapters 12–14.</em></li>
<li>The timer executes a very simple program which listens to a clock signal.
				<ul><li>By default, ATMega32U4 timers use use the built-in system clock which runs at 8,000,000 cycles per second (8MHz).</li>
<li>Clock signal can also come from external source.</li>
<li>After a fixed number of clock cycles, the timer updates a counter which occupies one or two 8-bit I/O registers.</li>
<li>The counter updates continuously as long as the timer is enabled.</li>
<li>When the counter reaches its maximum value, it wraps back to zero.
					<ul><li>The timer can also trigger an interrupt when the counter overflows.</li>
<li>This is covered in the next section.</li>
</ul></li>
<li>In addition to timekeeping, timers can be used to generate waveforms which in turn control external devices.
					<ul><li>Removing processing load from CPU.</li>
<li>Pulse Width Modulation (PWM) will be covered in Topic 11.</li>
</ul></li>
</ul></li>
</ul>
			<p>ATMega32U4 has four timers:</p>

			<ul><li>Timer 0: an 8 bit timer (counter ranges from 0 to 255)</li>
<li>Timer 1, 3: 16 bit timers (counter range from 0 to 65,535)</li>
<li>Timer 4: fast 10 bit timer (range from 0 to 1023)</li>
</ul>
			<p>Each timer has a set of dedicated  registers.</p>

		</div>
		
	
    
		<h3><a name="timer0_registers">Timer0 registers (Datasheet, Section 13.8)</a></h3>
		<div class="subsection">
			<p>Each timer has a set of dedicated control and counter registers. Details are shown for Timer 0; you can look up the datasheet to find the corresponding registers for Timers 1, 3, and 4.</p>

			<ul><li><code>TCCR0A</code> – Timer/Counter Control Register 0 A:
				<table cellspacing="0" border="1">
				<tbody><tr><td style="min-width:1in;">Bits</td><td style="min-width:1in;">7</td><td style="min-width:1in;">6</td><td style="min-width:1in;">5</td><td style="min-width:1in;">4</td><td style="min-width:1in;">3</td><td style="min-width:1in;">2</td><td style="min-width:1in;">1</td><td style="min-width:1in;">0</td></tr>
				<tr><td style="min-width:1in;">Name</td><td style="min-width:1in;"><code>COMOA1</code></td><td style="min-width:1in;"><code>COMOA0</code></td><td style="min-width:1in;"><code>COMOB1</code></td><td style="min-width:1in;"><code>COMOB0</code></td><td style="min-width:1in;">-</td><td style="min-width:1in;">-</td><td style="min-width:1in;"><code>WGM01</code></td><td style="min-width:1in;"><code>WGM00</code></td></tr>
				<tr><td style="min-width:1in;">Read/Write</td><td style="min-width:1in;">R/W</td><td style="min-width:1in;">R/W</td><td style="min-width:1in;">R/W</td><td style="min-width:1in;">R/W</td><td style="min-width:1in;">R</td><td style="min-width:1in;">R</td><td style="min-width:1in;">R/W</td><td style="min-width:1in;">R/W</td></tr>
				<tr><td style="min-width:1in;">initially</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td></tr>
				</tbody></table>
				<ul><li><code>COMOAx</code> = Compare Match Output A Mode: leave this at 0</li>
<li><code>COMOBx</code> = Compare Match Output B Mode: leave this at 0</li>
<li><code>WGM0x</code> = Waveform Generation  Mode: leave this at 0</li>
<li><b>TL;DR – For our current purposes either ignore, or assign 0, to this register</b></li>
</ul></li>
<li><code>TCCR0B</code> – Timer/Counter Control Register 0 B:
				<table cellspacing="0" border="1">
				<tbody><tr><td style="min-width:1in;">Bits</td><td style="min-width:1in;">7</td><td style="min-width:1in;">6</td><td style="min-width:1in;">5</td><td style="min-width:1in;">4</td><td style="min-width:1in;">3</td><td style="min-width:1in;">2</td><td style="min-width:1in;">1</td><td style="min-width:1in;">0</td></tr>
				<tr><td style="min-width:1in;">Name</td><td style="min-width:1in;"><code>FOC0A</code></td><td style="min-width:1in;"><code>FOC0B</code></td><td style="min-width:1in;">-</td><td style="min-width:1in;">-</td><td style="min-width:1in;"><code>WGM02</code></td><td style="min-width:1in;"><code>CS02</code></td><td style="min-width:1in;"><code>CS01</code></td><td style="min-width:1in;"><code>CS00</code></td></tr>
				<tr><td style="min-width:1in;">Read/Write</td><td style="min-width:1in;">W</td><td style="min-width:1in;">W</td><td style="min-width:1in;">R</td><td style="min-width:1in;">R</td><td style="min-width:1in;">R/W</td><td style="min-width:1in;">R/W</td><td style="min-width:1in;">R/W</td><td style="min-width:1in;">R/W</td></tr>
				<tr><td style="min-width:1in;">initially</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td></tr>
				</tbody></table>
				<ul><li><code>FOC0x</code> = Force output compare: leave these at 0.</li>
<li><code>WGM02</code> = Waveform Generation  Mode: leave this at 0.</li>
<li><code>CS02,CS01,CS00</code> = Clock Select.
					<br>
					Datasheet P 105.
					<br>
					These bits taken together form a 3-bit number which tells the timer how frequently to update the counter.
					The system clock speed is <em>pre-scaled</em> by dividing by the designated factor for each Clock Select combination.
					<br>
					<em>Figures in this table assume that the CPU speed is set to 8MHz in the <code>setup</code> phase.</em>
					<br>
					Values are:
					<table cellspacing="0" border="1">
						<tbody><tr><td><code>CS02:0</code></td><td>Counter updates…</td></tr>
						<tr><td><code>0b000</code></td><td>Never (Timer/Counter stopped)</td></tr>
						<tr><td><code>0b001</code></td><td>Every clock cycle (No pre-scaling) == 8,000,000 ticks/sec</td></tr>
						<tr><td><code>0b010</code></td><td>Every 8 clock cycles == 1,000,000 ticks/sec</td></tr>
						<tr><td><code>0b011</code></td><td>Every 64 clock cycles == 125,000 ticks/sec</td></tr>
						<tr><td><code>0b100</code></td><td>Every 256 clock cycles == 31,250 ticks/sec</td></tr>
						<tr><td><code>0b101</code></td>
						<td>Every 1024 clock cycles == 7812.5 ticks/sec</td>
						</tr>
						<tr><td><code>0b110</code></td><td>External clock source on T0 pin. Clock on falling edge.</td></tr>
						<tr><td><code>0b111</code></td><td>External clock source on T0 pin. Clock on rising edge.</td></tr>
					</tbody></table>
					<ul><li>We will not be using CS02:0 == 6 or CS02:0 == 7.</li>
</ul></li>
</ul></li>
<li><code>TCNT0</code> – Timer/Counter Register 0: an 8-bit numeric value. <strong>Where the count is stored.</strong></li>
<li><code>OCR0A</code> – Output Compare Register 0 A: an 8-bit numeric value. We will not be using this.</li>
<li><code>OCR0B</code> – Output Compare Register 0 B: an 8-bit numeric value. We will not be using this.</li>
<li><code>TIMSK0</code> – Timer/Counter Interrupt Mask Register 0: 
				<table cellspacing="0" border="1">
				<tbody><tr><td style="min-width:1in;">Bits</td><td style="min-width:1in;">7</td><td style="min-width:1in;">6</td><td style="min-width:1in;">5</td><td style="min-width:1in;">4</td><td style="min-width:1in;">3</td><td style="min-width:1in;">2</td><td style="min-width:1in;">1</td><td style="min-width:1in;">0</td></tr>
				<tr><td style="min-width:1in;">Name</td><td style="min-width:1in;">-</td><td style="min-width:1in;">-</td><td style="min-width:1in;">-</td><td style="min-width:1in;">-</td><td style="min-width:1in;">-</td><td style="min-width:1in;"><code>OCIE0B</code></td><td style="min-width:1in;"><code>OCIE0A</code></td><td style="min-width:1in;"><code>TOIE0</code></td></tr>
				<tr><td style="min-width:1in;">Read/Write</td><td style="min-width:1in;">R</td><td style="min-width:1in;">R</td><td style="min-width:1in;">R</td><td style="min-width:1in;">R</td><td style="min-width:1in;">R</td><td style="min-width:1in;">R/W</td><td style="min-width:1in;">R/W</td><td style="min-width:1in;">R/W</td></tr>
				<tr><td style="min-width:1in;">initially</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td><td style="min-width:1in;">0</td></tr>
				</tbody></table>
				<ul><li><code>OCIE0B</code> = Force output compare: leave these at 0</li>
<li><code>OCIE0A</code> = Force output compare: leave these at 0</li>
<li><code>TOIE0</code> = Enable Timer Overflow Interrupt.</li>
</ul></li>
</ul>
		</div> 

		
	
    
		<h3><a name="timer0">Case study: Set Up and Read Time From Timer0</a></h3>
		<div class="subsection">
			<p>In the present section we set up Timer 0, and see how to read the value of the clock.</p>

			<ul><li>First, decide how fast we want the Timer/Counter register to update.</li>
<li>Timer 0 is an 8 bit timer, so the Timer/Counter register will overflow every 256 ticks.</li>
<li>We know the number of ticks per second from the datasheet, so we can calculate how long it will take for the timer to count from 0 to 255  (the overflow period) and how many times the counter will overflow per second (the overflow frequency).<br>Definition: Frequency = 1 / Period.
					<br>
					<em>Figures in this table assume that the CPU speed is set to 8MHz in the <code>setup</code> phase.</em>
				<table cellspacing="0" border="1">
					<tbody><tr><td><code>CS02:0</code></td><td>Pre-scaler</td><td>Counter frequency</td><td>Overflow period = 256/freq</td><td>Overflow frequency</td></tr>
					<tr><td><code>0b000</code></td><td>0</td><td>0</td><td>n/a</td><td>n/a</td></tr>
					<tr><td><code>0b001</code></td><td>1</td><td>8MHz</td><td>0.000032s</td><td>31.25kHz</td></tr>
					<tr><td><code>0b010</code></td><td>8</td><td>1MHz</td><td>0.000256s</td><td>3.90625kHz</td></tr>
					<tr><td><code>0b011</code></td><td>64</td><td>125kHz</td><td>0.002048s</td><td>488.28125Hz</td></tr>
					<tr><td><code>0b100</code></td><td>256</td><td>31.25kHz</td><td>0.008192s</td><td>122.0703125Hz</td></tr>
					<tr><td><code>0b101</code></td><td>1024</td><td>7.8125kHz</td><td>0.032768s</td><td>30.517578125Hz</td></tr>
				</tbody></table></li>
<li>Using the table, and balancing the update speed against our needs, we choose a pre-scaler.</li>
<li>To set up Timer 0 to overflow about 30 times per second, we choose <code>CS02:0&nbsp;==&nbsp;0b101&nbsp;==&nbsp;5</code>, which corresponds to a pre-scaler of 1024.</li>
<li>Starting the timer then consists of:
				<ul><li>Set <code>TCCR0A&nbsp;=&nbsp;0;</code></li>
<li>Set <code>TCCR0B&nbsp;=&nbsp;5;</code></li>
</ul></li>
<li>To read the timer, we access <code>TCNT0</code>.
				<ul><li>The value of the counter is a number of ticks.</li>
<li>To convert from ticks back to seconds, we multiply by the pre-scaler and divide by clock speed.</li>
<li><code>#define&nbsp;FREQ&nbsp;8000000.0</code><br>
					<code>#define&nbsp;PRESCALE&nbsp;1024.0</code>
					<code>…</code><br>
					<code>double&nbsp;time&nbsp;=&nbsp;TCNT0&nbsp;*&nbsp;PRESCALE&nbsp;/&nbsp;FREQ;</code></li>
</ul></li>
</ul>
			<p>This procedure is demonstrated in <code>ReadTimer0.c</code>
				</p>
<p style="margin-left: 0.5in;"></p><pre style="line-height: 1.2; background: #2A211C; color: #BDAE9D; overflow-x: scroll; font-family: monospace; max-width: 100%;"><span class="sc2">/*
**	ReadTimer0.c
**
**	Demonstrates how to set up Timer0 in normal mode and
**	read the Timer/Counter. Effectively, displays 8-bit 
**	numbers at lightning speed.
**
**	See OverflowTimer0.c for use of the Timer Overflow
**	interrupt.
**
**	Lawrence Buckingham, QUT, September 2017.
**	(C) Queensland University of Technology.
*/</span>
<span class="sc10">#include &lt;stdint.h&gt;
</span><span class="sc10">#include &lt;stdio.h&gt;
</span><span class="sc10">#include &lt;avr/io.h&gt; 
</span><span class="sc10">#include &lt;avr/interrupt.h&gt;
</span><span class="sc10">#include &lt;util/delay.h&gt;
</span><span class="sc10">#include &lt;cpu_speed.h&gt;
</span>
<span class="sc10">#include &lt;graphics.h&gt;
</span><span class="sc10">#include &lt;macros.h&gt;
</span><span class="sc10">#include "lcd_model.h"
</span>
<span class="sc10">#define FREQ     (8000000.0)
</span><span class="sc10">#define PRESCALE (1024.0)
</span>
<span class="sc10">void</span> <span class="sc11">draw_double</span>(<span class="sc9">uint8_t</span> <span class="sc11">x</span>, <span class="sc9">uint8_t</span> <span class="sc11">y</span>, <span class="sc9">double</span> <span class="sc11">value</span>, <span class="sc9">colour_t</span> <span class="sc11">colour</span>);

<span class="sc10">void</span> <span class="sc11">setup</span>(<span class="sc10">void</span>) {
	<span class="sc11">set_clock_speed</span>(<span class="sc10">CPU_8MHz</span>);
	<span class="sc11">lcd_init</span>(<span class="sc10">LCD_DEFAULT_CONTRAST</span>);
	<span class="sc11">lcd_clear</span>();

	<span class="sc2">// Timer 0 in normal mode, with pre-scaler 1024 ==&gt; ~30Hz overflow.</span>
	<span class="sc11">TCCR0A</span> = <span class="sc4">0</span>;
	<span class="sc11">TCCR0B</span> = <span class="sc4">5</span>; 

	<span class="sc2">/*
	Alternatively:
		CLEAR_BIT(TCCR0B,WGM02);
		SET_BIT(TCCR0B,CS02);
		CLEAR_BIT(TCCR0B,CS01);
		SET_BIT(TCCR0B,CS00);
	*/</span>
}

<span class="sc9">char</span> <span class="sc11">buffer</span>[<span class="sc4">20</span>];

<span class="sc10">void</span> <span class="sc11">process</span>(<span class="sc10">void</span>) {
	<span class="sc9">double</span> <span class="sc11">time</span> = <span class="sc11">TCNT0</span> * <span class="sc10">PRESCALE</span> / <span class="sc10">FREQ</span>;
	<span class="sc11">clear_screen</span>();
	<span class="sc11">draw_string</span>(<span class="sc4">0</span>, <span class="sc4">0</span>, <span class="sc6">"TCNT0 = "</span>, <span class="sc11">FG_COLOUR</span>);
	<span class="sc11">draw_double</span>(<span class="sc4">10</span>, <span class="sc4">10</span>, <span class="sc11">time</span>, <span class="sc11">FG_COLOUR</span>);
	<span class="sc11">show_screen</span>();
}

<span class="sc9">int</span> <span class="sc11">main</span>(<span class="sc10">void</span>) {
	<span class="sc11">setup</span>();

	<span class="sc5">for</span> ( ;; ) {
		<span class="sc11">process</span>();
	}
}

<span class="sc2">// -------------------------------------------------</span>
<span class="sc2">// Helper functions.</span>
<span class="sc2">// -------------------------------------------------</span>

<span class="sc10">void</span> <span class="sc11">draw_double</span>(<span class="sc9">uint8_t</span> <span class="sc11">x</span>, <span class="sc9">uint8_t</span> <span class="sc11">y</span>, <span class="sc9">double</span> <span class="sc11">value</span>, <span class="sc9">colour_t</span> <span class="sc11">colour</span>) {
	<span class="sc11">snprintf</span>(<span class="sc11">buffer</span>, <span class="sc5">sizeof</span>(<span class="sc11">buffer</span>), <span class="sc6">"%f"</span>, <span class="sc11">value</span>);
	<span class="sc11">draw_string</span>(<span class="sc11">x</span>, <span class="sc11">y</span>, <span class="sc11">buffer</span>, <span class="sc11">colour</span>);
}
</pre>
		<p></p>

		</div>
	</div>
		<hr>
	
	

    
		<h2><a name="interrupt">The Timer Overflow Interrupt</a></h2>
		<div class="section">
		
	
    
		<h3><a name="interrupt_caveat">Caveat</a></h3>
		<div class="subsection">
			<p>Today we introduce interrupts in a superficial manner. We will encounter them again in subsequent topics.</p>
		</div>
		
	
    
		<h3><a name="whats_an_interrupt">What’s an interrupt?</a></h3>
		<div class="subsection">
			<p>Refer: Datasheet Section 4.8, Section 9.</p>
<p>An <em>interrupt</em> is a signal which is generated in response to an internal or external event (or change of state).</p>
<p>Examples:</p>

			<ul><li>Pin change.</li>
<li>Serial transfer complete</li>
<li>Timer overflow</li>
<li>+ plenty more.</li>
</ul>
			<p>Special functions called <em>Interrupt Service Routines</em> (also referred to as <em>interrupt handlers</em>) can be set up to process interrupts and are called in response to an event.</p>

			<ul><li>A list of interrupt vectors may be found on datasheet, p61.</li>
<li>Implementing an ISR is much the same as any other function.</li>
<li>The main difference is that we use one of the pre-defined macros to declare our interrupt.</li>
<li>In the present section, we will implement an ISR for the Timer 0 Overflow interrupt.</li>
<li>The ISR will be called automatically every time the Timer/Counter 0 register overflows (this is the event that triggers the interrupt).</li>
</ul>
			<p>When an interrupt occurs and an ISR is implemented for that interrupt:</p>

			<ol><li>The CPU temporarily stops whatever it is doing, but keeps a record of the state of the computation.</li>
<li>It then turns off interrupts so the ISR can run unimpeded.</li>
<li>The ISR is called, like a regular function.</li>
<li>After the ISR finishes, the CPU re-enables interrupts and then continues where it left off.</li>
</ol>
			<p>ISRs must use special global variables to transfer data.</p>

			<ul><li>ISRs cannot accept parameters, and cannot return a value.</li>
<li>Variables that may be changed by an ISR must be marked with the <code>volatile</code> keyword.</li>
<li><code>volatile</code> ensures that the compiler generates the right instructions to let other non-ISR code read the variables.</li>
</ul>
		</div>
		
	
    
		<h3><a name="timer_overflow_demo">Implementing Timer Overflow ISR</a></h3>
		<div class="subsection">
			<p>This subsection shows how to implement a Timer Overflow ISR for Timer 0.</p>

			<ul><li>Timer setup is much the same as the previous example.</li>
<li>We add two more instructions:
				<ul><li><code>TIMSK0&nbsp;=&nbsp;1;</code> enables the Timer Overflow interrupt for Timer 0. The same result would be obtained in this program by writing <code>TIMSK0&nbsp;|=&nbsp;(1&lt;&lt;TOIE0);</code> – clarity is in the eye of the beholder.</li>
<li><code>sei();</code> enables interrupts.</li>
</ul></li>
<li>The ISR is defined as a function with the signature<br>
				<code>ISR(TIMER0_OVF_vect)</code>.</li>
</ul>
			<p>This procedure is demonstrated in <code>TimerOverflow0.c</code>
				</p>
<p style="margin-left: 0.5in;"></p><pre style="line-height: 1.2; background: #2A211C; color: #BDAE9D; overflow-x: scroll; font-family: monospace; max-width: 100%;"><span class="sc2">/*
**	TimerOverflow0.c
**
**	Demonstrates how to set up a Timer Overflow ISR
**	for Timer 0, and uses it to implement a digital 
**	time counter.
**
**	Lawrence Buckingham, QUT, September 2017.
**	(C) Queensland University of Technology.
*/</span>
<span class="sc10">#include &lt;stdint.h&gt;
</span><span class="sc10">#include &lt;stdio.h&gt;
</span><span class="sc10">#include &lt;avr/io.h&gt; 
</span><span class="sc10">#include &lt;avr/interrupt.h&gt;
</span><span class="sc10">#include &lt;util/delay.h&gt;
</span><span class="sc10">#include &lt;cpu_speed.h&gt;
</span>
<span class="sc10">#include &lt;graphics.h&gt;
</span><span class="sc10">#include &lt;macros.h&gt;
</span><span class="sc10">#include "lcd_model.h"
</span>
<span class="sc10">#define FREQ     (8000000.0)
</span><span class="sc10">#define PRESCALE (1024.0)
</span>
<span class="sc10">void</span> <span class="sc11">draw_double</span>(<span class="sc9">uint8_t</span> <span class="sc11">x</span>, <span class="sc9">uint8_t</span> <span class="sc11">y</span>, <span class="sc9">double</span> <span class="sc11">value</span>, <span class="sc9">colour_t</span> <span class="sc11">colour</span>);

<span class="sc10">void</span> <span class="sc11">setup</span>(<span class="sc10">void</span>) {
	<span class="sc11">set_clock_speed</span>(<span class="sc10">CPU_8MHz</span>);
	<span class="sc11">lcd_init</span>(<span class="sc10">LCD_DEFAULT_CONTRAST</span>);
	<span class="sc11">lcd_clear</span>();

	<span class="sc2">// Timer 0 in normal mode, with pre-scaler 1024 ==&gt; ~30Hz overflow.</span>
	<span class="sc2">// Timer overflow on.</span>
	<span class="sc11">TCCR0A</span> = <span class="sc4">0</span>;
	<span class="sc11">TCCR0B</span> = <span class="sc4">5</span>; 
	<span class="sc11">TIMSK0</span> = <span class="sc4">1</span>; 

	<span class="sc2">/*
	Alternatively:
		CLEAR_BIT(TCCR0B,WGM02);
		SET_BIT(TCCR0B,CS02);
		CLEAR_BIT(TCCR0B,CS01);
		SET_BIT(TCCR0B,CS00);
		SET_BIT(TIMSK0, TOIE0);
	*/</span>

	<span class="sc2">// Enable timer overflow, and turn on interrupts.</span>
	<span class="sc11">sei</span>();
}

<span class="sc9">char</span> <span class="sc11">buffer</span>[<span class="sc4">20</span>];

<span class="sc5">volatile</span> <span class="sc9">int</span> <span class="sc11">overflow_counter</span> = <span class="sc4">0</span>;

<span class="sc11">ISR</span>(<span class="sc11">TIMER0_OVF_vect</span>) {
	<span class="sc11">overflow_counter</span> ++;
}

<span class="sc10">void</span> <span class="sc11">process</span>(<span class="sc10">void</span>) {
	<span class="sc9">double</span> <span class="sc11">time</span> = ( <span class="sc11">overflow_counter</span> * <span class="sc4">256.0</span> + <span class="sc11">TCNT0</span> ) * <span class="sc10">PRESCALE</span>  / <span class="sc10">FREQ</span>;
	<span class="sc11">clear_screen</span>();
	<span class="sc11">draw_string</span>(<span class="sc4">0</span>, <span class="sc4">0</span>, <span class="sc6">"Time = "</span>, <span class="sc11">FG_COLOUR</span>);
	<span class="sc11">draw_double</span>(<span class="sc4">10</span>, <span class="sc4">10</span>, <span class="sc11">time</span>, <span class="sc11">FG_COLOUR</span>);
	<span class="sc11">show_screen</span>();
}

<span class="sc9">int</span> <span class="sc11">main</span>(<span class="sc10">void</span>) {
	<span class="sc11">setup</span>();

	<span class="sc5">for</span> ( ;; ) {
		<span class="sc11">process</span>();
	}
}
<span class="sc2">// -------------------------------------------------</span>
<span class="sc2">// Helper functions.</span>
<span class="sc2">// -------------------------------------------------</span>

<span class="sc10">void</span> <span class="sc11">draw_double</span>(<span class="sc9">uint8_t</span> <span class="sc11">x</span>, <span class="sc9">uint8_t</span> <span class="sc11">y</span>, <span class="sc9">double</span> <span class="sc11">value</span>, <span class="sc9">colour_t</span> <span class="sc11">colour</span>) {
	<span class="sc11">snprintf</span>(<span class="sc11">buffer</span>, <span class="sc5">sizeof</span>(<span class="sc11">buffer</span>), <span class="sc6">"%f"</span>, <span class="sc11">value</span>);
	<span class="sc11">draw_string</span>(<span class="sc11">x</span>, <span class="sc11">y</span>, <span class="sc11">buffer</span>, <span class="sc11">colour</span>);
}
</pre>
		<p></p>

			<ul><li>In the ISR, we increment a counter to record how many times the timer has overflowed.</li>
<li>In process, we multiply the counter by 256 (the number of ticks per overflow) and add the residual value of <code>TCNT0</code> to get the total number of elapsed ticks. This is then multiplied by the scaling factor to convert to the number of elapsed seconds since the program started.</li>
<li>Note that in this implementation the counter wraps around and becomes negative when it passes 32,767. We could address this by counting with some wider numeric type.</li>
</ul>
		</div>
	</div>
		<hr>

	
	
	
	
	

    
		<h2><a name="appendices">Appendices</a></h2>
		<div class="section">

		
	
    
		<h3><a name="packed_boolean_array">Appendix 1: Bit-packed boolean arrays</a></h3>
		<div class="subsection">
			<ul><li>Microcontrollers typically have limited RAM, so when writing complex programs we take every chance to economise on memory use.</li>
<li>This subsection shows how we can use bit-level operations in an orderly way to pack multiple boolean values into simple variables, emulating a packed array of boolean.</li>
<li>The key idea is as follows:
				<ul><li>A variable of type <code>uint8_t</code> has 8 bits, so it can be used to remember up to 8 independent YES/NO values.</li>
<li>A variable of type <code>uint16_t</code> has 16 bits, so it can be used to remember up to 16 independent YES/NO values.</li>
<li>A variable of type <code>uint32_t</code> has 32 bits, so it can be used to remember up to 32 independent YES/NO values.</li>
</ul></li>
<li>The trick is to use bitwise operators:
				<ul><li><code>SET_BIT</code> stores a YES value in a packed array – <code>SET_BIT(collection,i)</code> is analogous to <code>collection[i]&nbsp;=&nbsp;true</code>;</li>
<li><code>CLEAR_BIT</code> stores a NO value in a packed array – <code>CLEAR_BIT(collection,i)</code> is analogous to <code>collection[i]&nbsp;=&nbsp;false</code>;</li>
<li><code>BIT_IS_SET</code> asks if the value is YES – <code>if&nbsp;(BIT_IS_SET(collection,i))&nbsp;{&nbsp;/*&nbsp;do&nbsp;something&nbsp;*/&nbsp;}</code> is analogous to <code>if&nbsp;(collection[i])&nbsp;{&nbsp;/*&nbsp;do&nbsp;something&nbsp;*/&nbsp;}</code>;</li>
</ul></li>
<li>Practical application:
				<ul><li>Remembering the state of a collection of switches.</li>
</ul></li>
</ul>
		</div> 

		 

		
	
    
		<h3><a name="cheat_sheet">Appendix 2: Digital I/O Cheat Sheet</a></h3>
		<div class="subsection">
			<p>Code snippets for frequently used registers:</p>

			<table cellspacing="0" border="1">
				<tbody><tr><td>Digital I/O</td><td>Data direction register</td><td>Detect</td><td>Turn on</td><td>Turn Off</td></tr>
				<tr><td>Joystick up</td><td><code>CLEAR_BIT(DDRD,&nbsp;1)</code></td><td><code>BIT_IS_SET(PIND,&nbsp;1)</code></td><td>n/a</td><td>n/a</td></tr>
				<tr><td>Joystick down</td><td><code>CLEAR_BIT(DDRB,&nbsp;7)</code></td><td><code>BIT_IS_SET(PINB,&nbsp;7)</code></td><td>n/a</td><td>n/a</td></tr>
				<tr><td>Joystick left</td><td><code>CLEAR_BIT(DDRB,&nbsp;1)</code></td><td><code>BIT_IS_SET(PINB,&nbsp;1)</code></td><td>n/a</td><td>n/a</td></tr>
				<tr><td>Joystick right</td><td><code>CLEAR_BIT(DDRD,&nbsp;0)</code></td><td><code>BIT_IS_SET(PIND,&nbsp;0)</code></td><td>n/a</td><td>n/a</td></tr>
				<tr><td>Joystick centre</td><td><code>CLEAR_BIT(DDRB,&nbsp;0)</code></td><td><code>BIT_IS_SET(PINB,&nbsp;0)</code></td><td>n/a</td><td>n/a</td></tr>
				<tr><td>Button left</td><td><code>CLEAR_BIT(DDRF,&nbsp;6)</code></td><td><code>BIT_IS_SET(PINF,&nbsp;6)</code></td><td>n/a</td><td>n/a</td></tr>
				<tr><td>Button right</td><td><code>CLEAR_BIT(DDRF,&nbsp;5)</code></td><td><code>BIT_IS_SET(PINF,&nbsp;5)</code></td><td>n/a</td><td>n/a</td></tr>
				<tr><td>LED0</td><td><code>SET_BIT(DDRB,&nbsp;2)&nbsp;&nbsp;</code></td><td>n/a</td><td><code>SET_BIT(PORTB,&nbsp;2)</code></td><td><code>CLEAR_BIT(PORTB,&nbsp;2)</code></td></tr>
				<tr><td>LED1</td><td><code>SET_BIT(DDRB,&nbsp;3)&nbsp;&nbsp;</code></td><td>n/a</td><td><code>SET_BIT(PORTB,&nbsp;3)</code></td><td><code>CLEAR_BIT(PORTB,&nbsp;3)</code></td></tr>
				<tr><td>LED2</td><td><code>SET_BIT(DDRD,&nbsp;6)&nbsp;&nbsp;</code></td><td>n/a</td><td><code>SET_BIT(PORTD,&nbsp;6)</code></td><td><code>CLEAR_BIT(PORTD,&nbsp;6)</code></td></tr>
			</tbody></table>
			
			<ul></ul>
		</div> 
	</div>
		<hr>

	<p style="text-align:center"><em>The End</em></p>
	<hr>
</body></html>